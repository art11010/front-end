// 2. 알고리즘 복잡도
// 시간 복잡도
// 단위 연산을 몇 번 수행하는지를 계산하여 알고리즘 수행시간 평가
// big-O(빅오) : '최악의 상황'을 고려한 성능 측정 결과
// θ(세타) : '평균 상황'을 고려한 성능 측정 결과(big-θ)
// Ω(오메가) : '최선의 상황'을 고려한 성능 측정 결과(big-Ω)

// big-O(빅오)의 복잡도(뒤로 갈수록 느림)
// O(log n),O(1) > O(n) > O(n log n) > O(n^2) > O(2^n) > O(n!)

// // O(log n) : n*2로 하여 n보다 빠름
// function big_o( n){
// 	let sum = 0;
// 	for(let i = 0; i < n; i *= 2){
// 		sum += 2;
// 	}
// 	return sum;
// }
// // O(1) : 상수
// function big_o(n){
// 	let sum = 0;
// 	sum = n * 2;
// 	return sum;
// }
// // O(n) : for문 1개
// function big_o(arr, n){
// 	let sum = 0;
// 	for(let i = 0; i < n; i++){
// 		sum += arr[i];
// 	}
// 	return sum;
// }
// // O(n^2) : for문 2개
// function big_o(arr, n){
// 	let sum = 0;
// 	for(let i = 0; i < n; i++){
// 		for(let i = 0; i < n; i++){
// 			sum += arr[i][j];
// 		}
// 	}
// 	return sum;
// }

// - - - - - - - - - - - - - - - - - - - -

// 3. 경우의 수
// 완전 탐색 : 순열, 조합, 중복 순열
// 순열 : 서로 다른 n개의 원소 중 r을 중복 없이 골라 '순서에 상관 있게' 나열(nPr)
// 조합 : 서로 다른 n개의 원소 중 r을 중복 없이 골라 '순서에 상관 없이' 나열(nCr)
// 중복 순열 : 서로 다른 n개의 원소 중 r을 '중복 있게' 골라 순서에 상관 있게 나열(nH)

// - - - - - - - - - - - - - - - - - - - -

// 4. 순열
// 서로 다른 n개의 원소 중 r을 중복 없이 골라 '순서에 상관 있게' 나열(nPr = n! / (n-r)!)